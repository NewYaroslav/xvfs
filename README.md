### Виртуальная файловая система

### Как это работает?
Создается файл, содержащий внутри себя виртуальную файловую систему, т.е. данный файл может содержать в себе множество "виртуальных" файлов. Каждый "виртуальный" файл по сути представляет из себя обычный массив данных. "Виртуальные" файлы можно читать, записывать, удалять из виртуальной файловой системы. Виртуальная файловая система (далее VFS) состоит из секторов. Размер секторов можно задать вручную перед созданием файла VFS. В конце каждого сектора отводится 4 байта под ссылку на следующий сектор, из которого можно читать или в который нужно записывать данные. Если при записи файла сектор оказался последним, в ссылке указывается число 0xFFFFFFFF. Каждый файл имеет свой уникальный id, начальный сектор считывания и данные о реальном и сжатом размере файла. Эти данные хранятся в заголовке файла VFS. Для имитации работы с именами файлов и папок класс VFS содержит функции, которые преобразуют строкове имя (путь к файлу) в хэш, который используется как уникальный id для виртуального файла.

### Особенности виртуальной файловой системы
+ Для быстрого поиска файла в заголовке используется бинарный поиск по его id
+ VFS разбивает все пространство на сектора
+ VFS запоминает пустые сектора и использует их в первую очередь при записи новых файлов или расширении размера уже существующих файлов
+ Файлы, которые имеют нулевой размер, запоминаются только в заголовке VFS. Указатель на первый сектор при этом имеет значение 0xFFFFFFFF.
+ VFS не использует "папок" и строковых имен файлов, все файлы представляют из себя отсортированный массив уникальных id с данными первого сектора файла и размера файла
+ VFS может читать или записывать файл только целиком, доступ к отдельным байтам виртуальных файлов на данный момент не реализован
+ Можно сжимать файлы (для компрессии и декопресии на данный момент поддерживается zlib, minilzo, lz4)

### Как установить?
Для начала использования VFS достаточно просто добавить в свой проект файлы src/xvfs.hpp и src/xvfs.cpp. Если необходимо использовать сжатие виртуальных файлов, добавьте в проект одну из библиотек (zlib, minilzo, lz4 или все сразу) и добавьте соответствующий макрос (XFVS_USE_ZLIB, XFVS_USE_MINLIZO, XFVS_USE_LZ4 или все сразу).

### Почему нет полноценной работы с файлами как в настоящей файловой системе?
Потому что для меня такой задачи не стояло и мне достаточно использовать такое решение

### Пример использования
+ Создать или читать файл виртуальной файловой системы
```C++
#include <xvfs.hpp>

int main() {
	const int sector_size = 48; // размер сектора по умолчанию
	// создим или читаем файл test.hex, сжатие при помощи библиотеки LZ4 (xvfs::USE_LZ4)
	xvfs VFS("test.hex", sector_size, xvfs::USE_LZ4); 
	//...
}

```
+ Записать данные в файл
```C++
	const int max_size = 512;
	char* test_data = new char[max_size];
	//...
	// здесь пишем данные в буфер test_data
	//...
	// записываем буфер в виртуальный файл test_file
	if(VFS.write_file("test_file", test_data, max_size)) {
		// файл успешно записан
	}
	/* 	Альтернативный фариант записи в файл
		const int test_file_id = 12345;
		VFS.write_file(test_file_id, test_data, max_size);
	*/
	//...
	
	delete[] test_data;

```
+ Записать данные в файл побайтно
```C++
	if(VFS.open("test_file", VFS.WRITE_FILE)) {
		// файл был удачно открыт для записи, теперь зарезервируем данные
		const int max_size = 512;
		if(VFS.reserve_memory(max_size)) {
			// память для записи была успешно зарезервирована, теперь пишем данные
			for(int j = 0; j < max_size; ++j) {
                char temp = rand();
                long len = VFS.write(&temp, sizeof(temp));
                if(len != sizeof(temp)) { 
					// возникла ошибка при записи (вышли за размер буфера)
				};
            }
		}
		if(VFS.close()) {
			// файл был успешно закрыт (запись в файл производится при закрытии файла)
		}
	}

```
+ Читать данные из файла
```C++
	char* test_data = NULL;
	int file_size = VFS.read_file("test_file", test_data);
	if(file_siz >= 0) {
		// если размер файла больше или равен 0, то файл был успешно считан
	} else {
		// иначе file_siz содержит номер ошибки
	}
	//...
	delete[] test_data;

```
+ Читать данные из файла побайтно
```
	if(VFS.open("test_file", VFS.READ_FILE)) {
		// файл был удачно открыт для чтения
		const int file_size = VFS.get_size(); // узнаем размер файла
		
		for(int j = 0; j < file_size; ++j) {
			char temp;
			long len = VFS.read(&temp, sizeof(temp));
			//...
		}

		if(VFS.close()) {
			// файл был успешно закрыт
		}
	}

```
+ Удалить файл
```C++
	if(VFS.delete_file("test_file")) {
		// файл был успешно удален
	}
```
+ Получить финормацию о виртуальной файловой системе
```C++
	// получим информацию о VFS
	unsigned long sector_size = 0;
	std::vector<xvfs::_xvfs_file_header> files;
	std::vector<unsigned long> empty_sectors;

	VFS.get_info(sector_size, files, empty_sectors);

	// выведем информацию на экран
	cout << "sector size " << sector_size << endl;
	cout << "files " << files.size() << endl;

	for(size_t i = 0; i < files.size(); ++i) {
	  cout << "*" << endl;
	  cout << "files hash: " << files[i].hash << endl; // уникальный id файла
	  cout << "files compress size: " << files[i].size << endl; // размер виртуального файла в VFS (после компрессии)
	  cout << "files uncompress size: " << files[i].real_size << endl; // реальный размер файла (после декомпресии)
	  cout << "files start sector: " << files[i].start_sector << endl; // первый сектор файла
	}

	cout << "empty_sectors " << empty_sectors.size() << endl; // количество пустых секторов

	for(size_t i = 0; i < empty_sectors.size(); ++i) {
	  cout << "sectors: " << empty_sectors[i] << endl; // пустой сектор
	}

```